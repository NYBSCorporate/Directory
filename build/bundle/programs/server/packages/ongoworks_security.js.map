{"version":3,"sources":["ongoworks:security/security-util.js","ongoworks:security/security-deny.js","ongoworks:security/security-api.js","ongoworks:security/security-rules.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAAA,uG;;AAEA,uB;;AAEA,e;AACA,U;AACA,e;AACA,e;AACA,e;AACA,sD;AACA,I;AACA,S;AACA,e;AACA,e;AACA,e;AACA,sD;AACA,G;AACA,E;;AAEA,G;AACA,gG;AACA,mF;AACA,iE;AACA,6F;AACA,uE;AACA,4D;AACA,G;AACA,sF;AACA,oE;AACA,uD;AACA,gC;AACA,yB;AACA,wB;AACA,G;AACA,8B;AACA,oB;AACA,K;AACA,oC;AACA,0B;AACA,K;AACA,E;;AAEA,G;AACA,qL;AACA,mE;AACA,yE;AACA,kG;AACA,yE;AACA,8D;AACA,G;AACA,sF;AACA,8B;AACA,sD;AACA,qD;AACA,O;AACA,6D;AACA,iE;AACA,sC;AACA,8C;AACA,O;AACA,K;AACA,E;;AAEA,G;AACA,iE;AACA,qF;AACA,+F;AACA,G;AACA,sE;AACA,8D;AACA,gB;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;ACxEA,E;AACA,qG;AACA,0D;AACA,G;;AAEA,kE;AACA,8B;AACA,+C;AACA,4C;AACA,kE;AACA,wC;AACA,4D;;AAEA,oE;AACA,iD;AACA,4C;AACA,W;;AAEA,gG;AACA,gF;AACA,+C;AACA,gD;AACA,W;AACA,S;AACA,O;AACA,K;AACA,E;;;;;;;;;;;;;;;;;;;AC1BA,iE;AACA,Y;AACA,iD;AACA,oB;;AAEA,4B;AACA,sB;AACA,K;AACA,wB;AACA,4B;AACA,I;AACA,oC;AACA,kC;AACA,oC;AACA,I;AACA,iE;AACA,+E;AACA,wC;AACA,iG;AACA,K;AACA,gF;AACA,0C;AACA,0E;AACA,K;AACA,kC;AACA,+B;AACA,iF;AACA,K;AACA,oD;AACA,sB;AACA,+B;AACA,+B;AACA,gB;AACA,S;AACA,kB;AACA,M;AACA,G;AACA,E;;AAEA,2B;AACA,8D;AACA,kB;AACA,oF;AACA,mF;AACA,gC;AACA,kD;AACA,kC;AACA,Y;AACA,0G;AACA,K;AACA,G;;AAEA,kC;;AAEA,uC;AACA,6C;AACA,6B;AACA,sD;AACA,oC;AACA,K;;AAEA,c;AACA,E;;AAEA,6C;AACA,kB;;AAEA,2C;AACA,uG;AACA,G;;AAEA,wF;AACA,gG;AACA,wF;AACA,oB;AACA,qD;;AAEA,yF;AACA,iG;AACA,iG;AACA,kC;AACA,mB;AACA,uD;AACA,oD;AACA,2D;AACA,sE;AACA,4E;AACA,O;AACA,O;;AAEA,mD;;AAEA,E;;AAEA,kE;AACA,kB;AACA,sF;AACA,kF;AACA,2D;AACA,0D;;AAEA,6C;AACA,0C;AACA,8B;AACA,mC;AACA,wD;AACA,gE;AACA,iD;AACA,8B;AACA,c;AACA,sB;AACA,O;AACA,+B;AACA,8B;AACA,2B;AACA,O;AACA,K;;AAEA,6D;AACA,iF;AACA,8B;AACA,mC;AACA,wD;AACA,gE;AACA,iD;AACA,8B;AACA,c;AACA,sB;AACA,O;AACA,2C;AACA,8B;AACA,2B;AACA,O;AACA,K;;AAEA,yF;AACA,K;AACA,E;;AAEA,sD;AACA,kD;AACA,E;;;;;;;;;;;;;;;;;;;AC7IA,E;AACA,iD;AACA,G;;AAEA,E;AACA,S;AACA,G;;AAEA,gC;AACA,Y;AACA,kB;AACA,qB;AACA,gB;AACA,G;AACA,G;;AAEA,E;AACA,Y;AACA,G;;AAEA,qC;AACA,Y;AACA,kB;AACA,sC;AACA,mB;AACA,G;AACA,G;;AAEA,E;AACA,mB;AACA,G;;AAEA,sC;AACA,Y;AACA,kB;AACA,sC;AACA,0B;AACA,G;AACA,G;;AAEA,E;AACA,iB;AACA,G;;AAEA,E;AACA,yB;AACA,G;AACA,2C;;AAEA,8C;;AAEA,sC;AACA,c;AACA,oB;AACA,wC;AACA,iB;AACA,+E;AACA,O;AACA,qB;AACA,gE;AACA,c;AACA,gD;AACA,O;AACA,K;AACA,K;;AAEA,C;;AAEA,E;AACA,8B;AACA,+B;AACA,G;AACA,gD;;AAEA,mD;;AAEA,sC;AACA,c;AACA,oB;AACA,wC;AACA,iB;AACA,+E;AACA,O;AACA,6C;AACA,K;AACA,K;;AAEA,C;;AAEA,E;AACA,sB;AACA,G;;AAEA,oC;AACA,Y;AACA,kB;AACA,uD;AACA,0B;AACA,kB;AACA,K;;AAEA,2C;;AAEA,sD;AACA,wC;AACA,O;AACA,G;AACA,G;;AAEA,sC;AACA,Y;AACA,kB;AACA,uD;AACA,0B;AACA,kB;AACA,K;;AAEA,2C;;AAEA,mD;AACA,wC;AACA,O;AACA,G;AACA,G","file":"/packages/ongoworks_security.js","sourcesContent":["/* global _, rulesByCollection:true, addFuncForAll:true, ensureCreated:true, ensureDefaultAllow:true */\n\nrulesByCollection = {};\n\nvar created = {\n  allow: {\n    insert: {},\n    update: {},\n    remove: {},\n    download: {} // for use with CollectionFS packages\n  },\n  deny: {\n    insert: {},\n    update: {},\n    remove: {},\n    download: {} // for use with CollectionFS packages\n  }\n};\n\n/**\n * Adds the given function as an allow or deny function for all specified collections and types.\n * @param {Array(Mongo.Collection)} collections Array of Mongo.Collection instances\n * @param {String}                  allowOrDeny \"allow\" or \"deny\"\n * @param {Array(String)}           types       Array of types (\"insert\", \"update\", \"remove\")\n * @param {Array(String)|null}      fetch       `fetch` property to use\n * @param {Function}                func        The function\n */\naddFuncForAll = function addFuncForAll(collections, allowOrDeny, types, fetch, func) {\n  // We always disable transformation, but we transform for specific\n  // rules upon running our deny function if requested.\n  var rules = {transform: null};\n  if (_.isArray(fetch)) {\n    rules.fetch = fetch;\n  }\n  _.each(types, function (t) {\n    rules[t] = func;\n  });\n  _.each(collections, function (c) {\n    c[allowOrDeny](rules);\n  });\n};\n\n/**\n * Creates the allow or deny function for the given collections if not already created. This ensures that this package only ever creates up to one allow and one deny per collection.\n * @param   {String}                  allowOrDeny \"allow\" or \"deny\"\n * @param   {Array(Mongo.Collection)} collections An array of collections\n * @param   {Array(String)}           types       An array of types (\"insert\", \"update\", \"remove\")\n * @param   {Array(String)|null}      fetch       `fetch` property to use\n * @param   {Function}                func        The function\n */\nensureCreated = function ensureCreated(allowOrDeny, collections, types, fetch, func) {\n  _.each(types, function (t) {\n    collections = _.reject(collections, function (c) {\n      return _.has(created[allowOrDeny][t], c._name);\n    });\n    addFuncForAll(collections, allowOrDeny, [t], null, func);\n    // mark that we've defined function for collection-type combo\n    _.each(collections, function (c) {\n      created[allowOrDeny][t][c._name] = true;\n    });\n  });\n};\n\n/**\n * Sets up default allow functions for the collections and types.\n * @param   {Array(Mongo.Collection)} collections Array of Mongo.Collection instances\n * @param   {Array(String)}           types       Array of types (\"insert\", \"update\", \"remove\")\n */\nensureDefaultAllow = function ensureDefaultAllow(collections, types) {\n  ensureCreated(\"allow\", collections, types, [], function () {\n    return true;\n  });\n};\n","/*\n * A single deny function runs all the deny functions registered by this package, allowing us to have\n * an OR relationship among multiple security rule chains.\n */\n\nensureSecureDeny = function ensureSecureDeny(collections, types) {\n  _.each(types, function (t) {\n    _.each(collections, function (collection) {\n      var collectionName = collection._name;\n      ensureCreated(\"deny\", [collection], [t], null, function () {\n        var args = _.toArray(arguments);\n        var rules = rulesByCollection[collectionName] || [];\n\n        // select only those rules that apply to this operation type\n        rules = _.select(rules, function (rule) {\n          return _.contains(rule._types, t);\n        });\n\n        // Loop through all defined rules for this collection. There is an OR relationship among\n        // all rules for the collection, so if any do NOT return true, we allow.\n        return _.every(rules, function (rule) {\n          return rule.deny(t, collection, args);\n        });\n      });\n    });\n  });\n};\n","// The `Security` object is exported and provides the package API\nSecurity = {\n  Rule: function SecurityRuleConstructor(types) {\n    var self = this;\n\n    if (!_.isArray(types)) {\n      types = [types];\n    }\n    self._types = types;\n    self._restrictions = [];\n  },\n  // the starting point of the chain\n  permit: function permit(types) {\n    return new Security.Rule(types);\n  },\n  defineMethod: function securityDefineMethod(name, definition) {\n    // Check whether a rule with the given name already exists; can't overwrite\n    if (Security.Rule.prototype[name]) {\n      throw new Error('A security method with the name \"' + name + '\" has already been defined');\n    }\n    // Make sure the definition argument is an object that has a `deny` property\n    if (!definition || !definition.deny) {\n      throw new Error('Security.defineMethod requires a \"deny\" function');\n    }\n    // Wrap transform, if provided\n    if (definition.transform) {\n      definition.transform = LocalCollection.wrapTransform(definition.transform);\n    }\n    Security.Rule.prototype[name] = function (arg) {\n      var self = this;\n      self._restrictions.push({\n        definition: definition,\n        arg: arg\n      });\n      return self;\n    };\n  }\n};\n\n// Security.Rule prototypes\nSecurity.Rule.prototype.collections = function (collections) {\n  var self = this;\n  // Make sure the `collections` argument is either a `Mongo.Collection` instance or\n  // an array of them. If it's a single collection, convert it to a one-item array.\n  if (!_.isArray(collections)) {\n    if (collections instanceof Mongo.Collection) {\n      collections = [collections];\n    } else {\n      throw new Error(\"The collections argument must be a Mongo.Collection instance or an array of them\");\n    }\n  }\n\n  self._collections = collections;\n\n  // Keep list keyed by collection name\n  _.each(collections, function (collection) {\n    var n = collection._name;\n    rulesByCollection[n] = rulesByCollection[n] || [];\n    rulesByCollection[n].push(self);\n  });\n\n  return self;\n};\n\nSecurity.Rule.prototype.apply = function () {\n  var self = this;\n\n  if (!self._collections || !self._types) {\n    throw new Error(\"At a minimum, you must call permit and collections methods for a security rule.\");\n  }\n\n  // If we haven't yet done so, set up a default, permissive `allow` function for all of\n  // the given collections and types. We control all security through `deny` functions only, but\n  // there must first be at least one `allow` function for each collection or all writes\n  // will be denied.\n  ensureDefaultAllow(self._collections, self._types);\n\n  // We need a combined `fetch` array. The `fetch` is optional and can be either an array\n  // or a function that takes the argument passed to the restriction method and returns an array.\n  // TODO for now we can't set fetch accurately; maybe need to adjust API so that we \"apply\" only\n  // after we've defined all rules\n  //var fetch = [];\n  //_.each(self._restrictions, function (restriction) {\n  //  if (_.isArray(restriction.definition.fetch)) {\n  //    fetch = fetch.concat(restriction.definition.fetch);\n  //  } else if (typeof restriction.definition.fetch === \"function\") {\n  //    fetch = fetch.concat(restriction.definition.fetch(restriction.arg));\n  //  }\n  //});\n\n  ensureSecureDeny(self._collections, self._types);\n\n};\n\nSecurity.Rule.prototype.deny = function (type, collection, args) {\n  var self = this;\n  // Loop through all defined restrictions. Restrictions are additive for this chained\n  // rule, so if any deny function returns true, this function should return true.\n  return _.any(self._restrictions, function (restriction) {\n    var doc, transform = restriction.definition.transform;\n\n    // If transform is a function, apply that\n    if (typeof transform === 'function') {\n      if (type === 'insert') {\n        doc = EJSON.clone(args[1]);\n        // The wrapped transform requires an _id, but we\n        // don't have access to the generatedId from Meteor API,\n        // so we'll fudge one and then remove it.\n        doc._id = Random.id();\n      } else {\n        doc = args[1];\n      }\n      args[1] = transform(doc);\n      if (type === 'insert') {\n        delete args[1]._id;\n      }\n    }\n\n    // If not transform: null, apply the collection transform\n    else if (transform !== null && typeof collection._transform === 'function') {\n      if (type === 'insert') {\n        doc = EJSON.clone(args[1]);\n        // The wrapped transform requires an _id, but we\n        // don't have access to the generatedId from Meteor API,\n        // so we'll fudge one and then remove it.\n        doc._id = Random.id();\n      } else {\n        doc = args[1];\n      }\n      args[1] = collection._transform(doc);\n      if (type === 'insert') {\n        delete args[1]._id;\n      }\n    }\n\n    return restriction.definition.deny.apply(this, [type, restriction.arg].concat(args));\n  });\n};\n\nMongo.Collection.prototype.permit = function (types) {\n  return Security.permit(types).collections(this);\n};\n","/*\n * This file defines built-in restriction methods\n */\n\n/*\n * No one\n */\n\nSecurity.defineMethod(\"never\", {\n  fetch: [],\n  transform: null,\n  deny: function () {\n    return true;\n  }\n});\n\n/*\n * Logged In\n */\n\nSecurity.defineMethod(\"ifLoggedIn\", {\n  fetch: [],\n  transform: null,\n  deny: function (type, arg, userId) {\n    return !userId;\n  }\n});\n\n/*\n * Specific User ID\n */\n\nSecurity.defineMethod(\"ifHasUserId\", {\n  fetch: [],\n  transform: null,\n  deny: function (type, arg, userId) {\n    return userId !== arg;\n  }\n});\n\n/*\n * Specific Roles\n */\n\n/*\n * alanning:roles support\n */\nif (Package && Package[\"alanning:roles\"]) {\n\n  var Roles = Package[\"alanning:roles\"].Roles;\n\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    transform: null,\n    deny: function (type, arg, userId) {\n      if (!arg) {\n        throw new Error('ifHasRole security rule method requires an argument');\n      }\n      if (arg.role) {\n        return !Roles.userIsInRole(userId, arg.role, arg.group);\n      } else {\n        return !Roles.userIsInRole(userId, arg);\n      }\n    }\n  });\n\n}\n\n/*\n * nicolaslopezj:roles support\n * Note: doesn't support groups\n */\nif (Package && Package[\"nicolaslopezj:roles\"]) {\n\n  var Roles = Package[\"nicolaslopezj:roles\"].Roles;\n\n  Security.defineMethod(\"ifHasRole\", {\n    fetch: [],\n    transform: null,\n    deny: function (type, arg, userId) {\n      if (!arg) {\n        throw new Error('ifHasRole security rule method requires an argument');\n      }\n      return !Roles.userHasRole(userId, arg);\n    }\n  });\n\n}\n\n/*\n * Specific Properties\n */\n\nSecurity.defineMethod(\"onlyProps\", {\n  fetch: [],\n  transform: null,\n  deny: function (type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) {\n      arg = [arg];\n    }\n\n    fieldNames = fieldNames || _.keys(doc);\n\n    return !_.every(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  }\n});\n\nSecurity.defineMethod(\"exceptProps\", {\n  fetch: [],\n  transform: null,\n  deny: function (type, arg, userId, doc, fieldNames) {\n    if (!_.isArray(arg)) {\n      arg = [arg];\n    }\n\n    fieldNames = fieldNames || _.keys(doc);\n\n    return _.any(fieldNames, function (fieldName) {\n      return _.contains(arg, fieldName);\n    });\n  }\n});\n"]}